# Nome do Workflow
name: Criador de Reposit√≥rio

# Gatilho do workflow
on:
  workflow_dispatch:
    inputs:
      repoName:
        description: "Nome do novo reposit√≥rio (ex: meu-projeto-novo)"
        required: true
        type: string
      repoDescription:
        description: "Descri√ß√£o breve do reposit√≥rio"
        required: false
        type: string
      repoTeam:
        description: "Slug do time principal que ser√° dono do reposit√≥rio (ex: devops)"
        required: true
        type: string
      templateRepo:
        description: "Reposit√≥rio template para copiar os arquivos (ex: meu-template-padrao)"
        required: true
        type: string
        default: 'nosso-repo-template'
      templateBranch:
        description: "Branch do reposit√≥rio template a ser usado"
        required: true
        type: string
        default: 'main'

jobs:
  create-repository:
    runs-on: ubuntu-latest
    steps:
      - name: Gerar Token de Autentica√ß√£o do GitHub App
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Executar Script de Cria√ß√£o e Configura√ß√£o do Reposit√≥rio
        uses: actions/github-script@v7
        with:
          # Usa o token gerado pelo GitHub App, que √© mais seguro
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            // --- Par√¢metros de Entrada ---
            const orgName = context.repo.owner;
            const repoName = "${{ github.event.inputs.repoName }}".trim();
            const repoDescription = "${{ github.event.inputs.repoDescription }}" || `${repoName} criado via automa√ß√£o`;
            const repoTeam = "${{ github.event.inputs.repoTeam }}".trim().toLowerCase();
            const templateRepo = "${{ github.event.inputs.templateRepo }}".trim();
            const templateBranch = "${{ github.event.inputs.templateBranch }}".trim();

            if (!repoName || !repoTeam || !templateRepo) {
              core.setFailed('Par√¢metros obrigat√≥rios n√£o foram fornecidos.');
              return;
            }

            // --- Configura√ß√µes Adicionais ---
            const defaultBranch = "main";
            const branchesToCreate = ["develop", "homolog"];
            const branchesToProtect = ["main", "develop", "homolog"];

            // Fun√ß√£o para logar mensagens no console
            const log = (message) => console.log(message);

            // 1. Criar o Reposit√≥rio (ou obter se j√° existir)
            let repo;
            let repoExisted = false;
            log(`Iniciando processo para o reposit√≥rio: ${repoName}`);
            try {
              const response = await github.rest.repos.createInOrg({
                org: orgName,
                name: repoName,
                description: repoDescription,
                private: true,
                auto_init: true, // Cria o repo com um README inicial para ter o branch 'main'
              });
              repo = response.data;
              log(`‚úÖ Reposit√≥rio "${repo.name}" criado com sucesso.`);
            } catch (error) {
              if (error.status === 422 && error.message.includes("name already exists")) {
                log(` Reposit√≥rio "${repoName}" j√° existe. Usando o existente.`);
                const response = await github.rest.repos.get({ owner: orgName, repo: repoName });
                repo = response.data;
                repoExisted = true;
              } else {
                core.setFailed(`‚ùå Erro ao criar o reposit√≥rio: ${error.message}`);
                return;
              }
            }

            // 2. Adicionar Permiss√µes para Times
            const permitedTeams = [repoTeam, 'techleads', 'devops', 'productionteam'];
            for (const teamSlug of [...new Set(permitedTeams)]) { // Usa Set para evitar duplicados
              try {
                log(`Adicionando permiss√£o de 'push' para o time "${teamSlug}"`);
                await github.rest.teams.addOrUpdateRepoPermissionsInOrg({
                  org: orgName,
                  team_slug: teamSlug,
                  owner: orgName,
                  repo: repo.name,
                  permission: 'push',
                });
              } catch (error) {
                core.warning(`Aviso: N√£o foi poss√≠vel adicionar o time "${teamSlug}". Verifique se o slug est√° correto. Erro: ${error.message}`);
              }
            }

            // Apenas executa a c√≥pia e cria√ß√£o de branches se o repo for novo
            if (!repoExisted) {
              // 3. Copiar Arquivos do Reposit√≥rio Template
              log(`Copiando arquivos de "${templateRepo}" (branch: ${templateBranch})...`);
              const pathsToCopy = [".github", "envs-dev.yaml", "envs-hml.yaml", "envs-prd.yaml", "secrets.yaml", "gh-actions-config.yaml"];

              const copyFile = async (path) => {
                try {
                  const contentResponse = await github.rest.repos.getContent({
                    owner: orgName,
                    repo: templateRepo,
                    path: path,
                    ref: templateBranch,
                  });

                  if (Array.isArray(contentResponse.data)) { // Se for um diret√≥rio
                    for (const item of contentResponse.data) {
                      await copyFile(item.path); // Chama recursivamente
                    }
                  } else { // Se for um arquivo
                    log(` -> Copiando arquivo: ${contentResponse.data.path}`);
                    await github.rest.repos.createOrUpdateFileContents({
                      owner: orgName,
                      repo: repo.name,
                      path: contentResponse.data.path,
                      message: `ci: Adiciona arquivo de template ${contentResponse.data.name}`,
                      content: contentResponse.data.content,
                      branch: defaultBranch,
                    });
                  }
                } catch (error) {
                  if (error.status === 404) {
                     core.warning(`Aviso: O caminho/arquivo "${path}" n√£o foi encontrado no template e ser√° ignorado.`);
                  } else {
                     core.warning(`Aviso ao copiar "${path}": ${error.message}`);
                  }
                }
              };

              for (const path of pathsToCopy) {
                await copyFile(path);
              }
              log('‚úÖ C√≥pia de arquivos do template finalizada.');

              // 4. Criar Branches de Desenvolvimento
              log(`Criando branches a partir de '${defaultBranch}'...`);
              const mainRef = await github.rest.git.getRef({ owner: orgName, repo: repo.name, ref: `heads/${defaultBranch}` });
              for (const branchName of branchesToCreate) {
                try {
                  await github.rest.git.createRef({
                    owner: orgName,
                    repo: repo.name,
                    ref: `refs/heads/${branchName}`,
                    sha: mainRef.data.object.sha,
                  });
                  log(` -> Branch '${branchName}' criado.`);
                } catch (error) {
                  if (error.status === 422) { log(` -> Branch '${branchName}' j√° existe.`); }
                  else { core.warning(`Aviso ao criar branch '${branchName}': ${error.message}`); }
                }
              }
            } else {
              log(" Reposit√≥rio j√° existia, pulando c√≥pia de arquivos e cria√ß√£o de branches.");
            }

            // 5. Aplicar Regras de Prote√ß√£o de Branch
            log('Aplicando regras de prote√ß√£o...');
            for (const branchName of branchesToProtect) {
              try {
                await github.rest.repos.updateBranchProtection({
                  owner: orgName,
                  repo: repo.name,
                  branch: branchName,
                  required_status_checks: null,
                  enforce_admins: true,
                  required_pull_request_reviews: {
                    dismiss_stale_reviews: true,
                    require_code_owner_reviews: false,
                    required_approving_review_count: 1,
                  },
                  restrictions: null,
                });
                log(` -> Regras aplicadas com sucesso ao branch '${branchName}'.`);
              } catch (error) {
                core.warning(`Aviso: N√£o foi poss√≠vel proteger o branch '${branchName}'. Ele existe? Erro: ${error.message}`);
              }
            }

            log(`\nüéâ Processo conclu√≠do! Reposit√≥rio dispon√≠vel em: ${repo.html_url}`);
