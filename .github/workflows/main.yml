# Nome do Workflow
name: Criador de Reposit√≥rio

# Gatilho do workflow
on:
  workflow_dispatch:
    inputs:
      repoName:
        description: "Nome do novo reposit√≥rio (ex: meu-projeto-novo)"
        required: true
        type: string
      repoDescription:
        description: "Descri√ß√£o breve do reposit√≥rio"
        required: false
        type: string
      repoTeam:
        description: "Slug do time principal que ser√° dono do reposit√≥rio (ex: time-desenvolvimento)"
        required: true
        type: string

jobs:
  create-and-configure-repository:
    runs-on: ubuntu-latest
    steps:
      # Passo 1: Gerar um token de curta dura√ß√£o a partir do GitHub App.
      - name: Gerar Token de Autentica√ß√£o do GitHub App
        id: generate_token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      # Passo 2: Executar o script principal usando o token gerado.
      - name: Criar e Configurar Reposit√≥rio via Script
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            // --- Par√¢metros de Entrada e Configura√ß√µes Fixas ---
            const orgName = context.repo.owner;
            const repoName = "${{ github.event.inputs.repoName }}".trim();
            const repoDescription = "${{ github.event.inputs.repoDescription }}" || `Reposit√≥rio ${repoName} criado via automa√ß√£o`;
            const mainTeamSlug = "${{ github.event.inputs.repoTeam }}".trim().toLowerCase();
            
            // Reposit√≥rio e branch de template fixos
            const templateRepo = 'trade-actions';
            const templateBranch = 'stable';
            const defaultBranch = 'main';

            const log = (message) => core.info(message);

            try {
              // --- 1. CRIAR UM REPOSIT√ìRIO NOVO E VAZIO ---
              log(`Iniciando a cria√ß√£o do reposit√≥rio "${repoName}"...`);
              const createRepoResponse = await github.rest.repos.createInOrg({
                org: orgName,
                name: repoName,
                description: repoDescription,
                private: true,
                auto_init: true, // Cria o repo com um README para ter o branch 'main'
              });
              const repo = createRepoResponse.data;
              log(`‚úÖ Reposit√≥rio "${repo.name}" criado com sucesso! URL: ${repo.html_url}`);

              // --- 2. COPIAR ARQUIVOS DO TEMPLATE ---
              log(`Copiando arquivos de "${templateRepo}" (branch: ${templateBranch})...`);
              const pathsToCopy = [".github", "envs-dev.yaml", "envs-hml.yaml", "envs-prd.yaml", "secrets.yaml", "gh-actions-config.yaml"];
              
              const copyContent = async (path) => {
                try {
                  const contentResponse = await github.rest.repos.getContent({
                    owner: orgName,
                    repo: templateRepo,
                    path: path,
                    ref: templateBranch,
                  });

                  if (Array.isArray(contentResponse.data)) { // Se for um diret√≥rio
                    for (const item of contentResponse.data) {
                      await copyContent(item.path); // Chama recursivamente para cada item no diret√≥rio
                    }
                  } else { // Se for um arquivo
                    log(` -> Copiando arquivo: ${contentResponse.data.path}`);
                    await github.rest.repos.createOrUpdateFileContents({
                      owner: orgName,
                      repo: repo.name,
                      path: contentResponse.data.path,
                      message: `ci: Adiciona arquivo de template '${contentResponse.data.name}'`,
                      content: contentResponse.data.content, // O conte√∫do j√° vem em base64
                      branch: defaultBranch,
                    });
                  }
                } catch (error) {
                  if (error.status === 404) {
                     core.warning(`‚ö†Ô∏è Aviso: O caminho/arquivo "${path}" n√£o foi encontrado no template e ser√° ignorado.`);
                  } else {
                     core.warning(`‚ö†Ô∏è Aviso ao copiar "${path}": ${error.message}`);
                  }
                }
              };

              for (const path of pathsToCopy) {
                await copyContent(path);
              }
              log('‚úÖ C√≥pia de arquivos do template finalizada.');

              // --- 3. CRIAR BRANCHES PADR√ÉO (develop, homolog) ---
              log("Criando branches padr√£o...");
              const mainRef = await github.rest.git.getRef({ owner: orgName, repo: repo.name, ref: `heads/${defaultBranch}` });
              const mainSha = mainRef.data.object.sha;

              const branchesToCreate = ["develop", "homolog"];
              for (const branchName of branchesToCreate) {
                await github.rest.git.createRef({ owner: orgName, repo: repo.name, ref: `refs/heads/${branchName}`, sha: mainSha });
                log(` -> Branch '${branchName}' criado.`);
              }

              // --- 4. ADICIONAR PERMISS√ïES PARA TIMES ---
              log("Adicionando permiss√µes para os times...");
              const teamsToAssign = [mainTeamSlug, 'techleads', 'devops', 'productionteam'];
              for (const teamSlug of [...new Set(teamsToAssign)]) {
                await github.rest.teams.addOrUpdateRepoPermissionsInOrg({ org: orgName, team_slug: teamSlug, owner: orgName, repo: repo.name, permission: 'push' });
                log(` -> Permiss√£o de 'push' adicionada para "${teamSlug}".`);
              }

              // --- 5. APLICAR REGRAS DE PROTE√á√ÉO DE BRANCH ---
              log('Aplicando regras de prote√ß√£o de branch...');
              const branchesToProtect = ["main", "develop", "homolog"];
              for (const branchName of branchesToProtect) {
                await github.rest.repos.updateBranchProtection({
                  owner: orgName,
                  repo: repo.name,
                  branch: branchName,
                  required_status_checks: null,
                  enforce_admins: true,
                  required_pull_request_reviews: { required_approving_review_count: 1 },
                  restrictions: null,
                });
                log(` -> Regra de prote√ß√£o aplicada ao branch '${branchName}'.`);
              }

              log(`\nüéâ Processo conclu√≠do com sucesso!`);

            } catch (error) {
              if (error.status === 422 && error.message.includes("name already exists")) {
                core.setFailed(`‚ùå Erro: O reposit√≥rio "${repoName}" j√° existe na organiza√ß√£o "${orgName}".`);
              } else {
                core.setFailed(`‚ùå Erro cr√≠tico durante a execu√ß√£o: ${error.message}.`);
              }
            }
